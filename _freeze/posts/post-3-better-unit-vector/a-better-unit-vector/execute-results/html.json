{
  "hash": "f20bbee1aa5a06b8e19b68ad54b8425b",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"The Hyper-Tanh Peel: A Novel Parameterization for Unit Vectors\"\nauthor: \"Sean Pinkney\"\ndate: \"2026-01-15\"\ncategories: [stan, parameterizations]\nbibliography: references.bib\nformat:\n  html:\n    code-fold: true\n---\n\n## 1. Introduction\n\nParameterizing unit vectors (points on a hypersphere $S^{K-1}$) in Bayesian models presents unique challenges.\n\n1.  Hyperspherical coordinates (angles) involve boundaries ($0, \\pi$) that hinder Hamiltonian Monte Carlo (HMC) sampling.\n2.  @muller1959's method (normalizing standard Gaussians, how Stan parameterizes `unit_vector`) is isotropic but over-parameterized ($K$ parameters for $K-1$ dimensions) and suffers from a gradient singularity at the origin.\n\nI'm calling this the **hyper-tanh peel** bijective parameterization. It is a mapping $\\mathbb{R}^{K-1} \\to S^{K-1}$. It uses \"Logistic Geometry\" to create a smooth, unconstrained manifold that is numerically stable and avoids the singularities of traditional methods.\n\n## 2. Mathematical Formulation\n\n### The Transformation\n\nThe method \"peels\" dimensions one by one using the hyperbolic tangent function ($\\tanh$), which maps $(-\\infty, \\infty) \\to (-1, 1)$, and closes the remaining 2D subspace with a stereographic projection.\n\n**Algorithm:**\n\nLet $r_1 = 1$. For $i = 1, \\dots, K-2$:\n\n$$\n\\begin{aligned}\ny_i &= r_i \\cdot \\tanh(x_i) \\\\\nr_{i+1} &= r_i \\cdot \\text{sech}(x_i) \\quad \\text{where } \\text{sech}(x) = \\frac{1}{\\cosh(x)} = \\sqrt{1 - \\tanh^2(x)}\n\\end{aligned}\n$$\n\nThe final two dimensions are parameterized as a stereographic coordinate:\n\n$$\n\\begin{aligned}\n\\theta &= 2 \\arctan(x_{K-1}) \\\\\ny_{K-1} &= r_{K-1} \\cos(\\theta) = r_{K-1} \\frac{1 - x_{K-1}^2}{1 + x_{K-1}^2} \\\\\ny_{K} &= r_{K-1} \\sin(\\theta) = r_{K-1} \\frac{2 x_{K-1}}{1 + x_{K-1}^2}\n\\end{aligned}\n$$\n\n### The Jacobian Adjustment\n\nThe log-determinant of the Jacobian is:\n\n$$\n\\log |J| = \\sum_{i=1}^{K-2} -(K-i) \\log(\\cosh(x_i)) + \\log(2) - \\log(1 + x_{K-1}^2)\n$$\n\nThis implies that: 1. The peeling parameters follow a sech distribution: $p(x_i) \\propto \\text{sech}^{K-i}(x_i)$. 2. The core parameter follows a cauchy distribution: $p(x_{K-1}) \\propto (1+x_{K-1}^2)^{-1}$.\n\n## 3. Logistic Geometry & Gradient Stability\n\nA problem with @muller1959's method when used with HMC is the singularity at the origin. In Muller's parameterization, $\\mathbf{y} = \\mathbf{z} / \\|\\mathbf{z}\\|$. As $\\mathbf{z} \\to 0$, the gradient $\\nabla_\\mathbf{z} \\mathbf{y}$ explodes to infinity. This creates a \"funnel\" that traps HMC samplers.\n\nAdvantages of this parameterization: The Hyper-Tanh Peel maps the origin of the parameter space $\\mathbf{x}=\\mathbf{0}$ to the \"North Pole\" of the sphere $\\mathbf{y}=(1, 0, \\dots, 0)$.\n\nThe derivative of the mapping is governed by $\\frac{d}{dx} \\tanh(x) = \\text{sech}^2(x)$. \\* At $x=0$, $\\text{sech}^2(0) = 1$. \\* The gradient is linear and bounded. There is no singularity.\n\n## 4. Visual Verification\n\nThis demonstrates two key properties using R: 1. Uniformity: With Jacobian correction, Hyper-Tanh matches @muller1959's isotropy. 2. Stability: Hyper-Tanh has bounded gradients where Muller explodes.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(ggplot2)\nlibrary(patchwork)\nlibrary(dplyr)\nlibrary(tidyr)\n\n# Load blog theme\nsource(\"../../R/theme_blog.R\")\n\n# --- Define Methods ---\n\n# 1. Muller's Method (Standard)\ngenerate_muller <- function(N, K=3) {\n  z <- matrix(rnorm(N * K), ncol=K)\n  y <- z / sqrt(rowSums(z^2))\n  return(data.frame(y, Method=\"Muller (1959)\"))\n}\n\n# 2. Hyper-Tanh (Uniform via Inverse Jacobian Sampling)\ngenerate_hypertanh_uniform <- function(N, K=3) {\n  y_out <- matrix(0, nrow=N, ncol=K)\n  r <- rep(1, N)\n  \n  # Peel Phase (Dim 1 to K-2)\n  for(i in 1:(K-2)) {\n    # Inverse sample from p(x) ~ sech^(K-i)(x)\n    # For K=3, i=1: p(x) ~ sech^2(x) -> CDF = (tanh(x)+1)/2\n    u <- runif(N)\n    # Clip for stability\n    u <- pmax(pmin(u, 1 - 1e-7), 1e-7)\n    x <- atanh(2*u - 1)\n    \n    y_out[,i] <- r * tanh(x)\n    r <- r * (1 / cosh(x))\n  }\n  \n  # Core Phase (Stereographic)\n  # p(x) ~ 1/(1+x^2) -> Cauchy(0,1)\n  x_last <- rcauchy(N)\n  denom <- 1 + x_last^2\n  \n  y_out[,K-1] <- r * (1 - x_last^2) / denom\n  y_out[,K]   <- r * (2 * x_last) / denom\n  \n  return(data.frame(y_out, Method=\"Hyper-Tanh\"))\n}\n```\n:::\n\n\n### Experiment A: Uniformity Check\n\nI generate 2,000 points on a 3D sphere ($S^2$) using both methods and verify that they cover the projected disk uniformly.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nset.seed(42)\nN <- 2000\ndf_muller <- generate_muller(N)\ndf_ht <- generate_hypertanh_uniform(N)\ncolnames(df_muller)[1:2] <- c(\"y1\", \"y2\")\ncolnames(df_ht)[1:2] <- c(\"y1\", \"y2\")\n\ndf_all <- rbind(df_muller, df_ht)\n\n# X-axis limits: sphere diameter (2) should be 80% of total width\n# So total width = 2 / 0.8 = 2.5, meaning xlim = c(-1.25, 1.25)\nxlims <- c(-1.25, 1.25)\n\n# Split data by method for individual plots\ndf_ht_only <- df_all[df_all$Method == \"Hyper-Tanh\", ]\ndf_muller_only <- df_all[df_all$Method == \"Muller (1959)\", ]\n\n# Use facet_grid for proper alignment\n# Reshape data for combined plot\ndf_scatter <- df_all %>%\n  mutate(plot_type = \"Isotropy\")\n\ndf_hist <- df_all %>%\n  mutate(plot_type = \"Marginal\")\n\n# Scatter plot with facets\np_scatter <- ggplot(df_all, aes(x=y1, y=y2)) +\n  annotate(\"path\", x=cos(seq(0,2*pi,0.01)), y=sin(seq(0,2*pi,0.01)), color=\"grey50\") +\n  geom_point(aes(color=Method), size=0.8, alpha=0.5) +\n  facet_wrap(~Method, nrow=1) +\n  scale_color_manual(values=c(blog_colors$teal, blog_colors$purple)) +\n  scale_x_continuous(limits=xlims, breaks=seq(-1, 1, 0.5)) +\n  scale_y_continuous(limits=xlims, breaks=seq(-1, 1, 0.5)) +\n  theme_blog() +\n  labs(x=\"y1\", y=\"y2\") +\n  theme(legend.position=\"none\",\n        aspect.ratio=1,\n        panel.spacing = unit(1, \"lines\"))\n\n# Histogram with facets\np_hist <- ggplot(df_all, aes(x=y1, fill=Method)) +\n  geom_histogram(aes(y=after_stat(density)), bins=30, alpha=0.6) +\n  facet_wrap(~Method, nrow=1) +\n  scale_fill_manual(values=c(blog_colors$teal, blog_colors$purple)) +\n  scale_x_continuous(limits=xlims, breaks=seq(-1, 1, 0.5)) +\n  theme_blog() +\n  labs(x=\"y1\", y=\"Density\") +\n  theme(legend.position=\"none\",\n        strip.text=element_blank(),\n        panel.spacing = unit(1, \"lines\"))\n\n# Stack with patchwork\np_scatter / p_hist + plot_layout(heights = c(1, 0.5))\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\nWarning: Removed 4 rows containing missing values or values outside the scale range\n(`geom_bar()`).\n```\n\n\n:::\n\n::: {.cell-output-display}\n![](a-better-unit-vector_files/figure-html/uniformity-plot-1.png){width=100%}\n:::\n:::\n\n\nResult: The Hyper-Tanh parameterization, when sampled with the correct Jacobian prior, is indistinguishable from Muller's method. It is perfectly uniform.\n\n### Experiment B: Gradient Stability (The \"y=0\" Singularity)\n\nHere I calculate the magnitude of the gradient $\\left\\| \\frac{d\\mathbf{y}}{dp} \\right\\|$ as the parameter $p$ passes through the origin.\n\n1.  Muller: $p=z$. $\\mathbf{y} = z/|z|$. Gradient $\\propto 1/|z|$.\n2.  Hyper-Tanh: $p=x$. $y = \\tanh(x)$. Gradient $\\propto \\text{sech}^2(x)$.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Define parameter sequence crossing zero\np_seq <- seq(-2, 2, length.out=500)\nepsilon <- 1e-9\n\n# Muller Gradient Norm approx (1/|p|)\ngrad_muller <- 1 / sqrt(p_seq^2 + epsilon)\n\n# Hyper-Tanh Gradient Norm approx (sech^2(p))\ngrad_ht <- (1 / cosh(p_seq))^2\n\ndf_grad <- data.frame(\n  Parameter = rep(p_seq, 2),\n  Gradient = c(grad_muller, grad_ht),\n  Method = rep(c(\"Muller (z -> z/|z|)\", \"Hyper-Tanh (x -> y)\"), each=500)\n)\n\nggplot(df_grad, aes(x=Parameter, y=Gradient, color=Method)) +\n  geom_line(linewidth=1.2) +\n  scale_y_log10() +\n  scale_color_manual(values=c(blog_colors$teal, blog_colors$purple)) +\n  theme_blog() +\n  labs(title = \"Gradient Stability at the Origin\",\n       subtitle = \"Muller explodes (Singularity). Hyper-Tanh is stable (Linear).\",\n       y = \"Gradient Magnitude (Log Scale)\",\n       x = \"Parameter Value\") +\n  geom_vline(xintercept = 0, linetype=\"dashed\", alpha=0.5)\n```\n\n::: {.cell-output-display}\n![](a-better-unit-vector_files/figure-html/gradient-plot-1.png){width=100%}\n:::\n:::\n\n\nResult: The Hyper-Tanh Peel eliminates the topological singularity. The sampler can pass through the origin without experiencing infinite forces.\n\n## 5. Stan Implementation\n\nCopy this block directly into your Stan program.\n\n``` stan\nfunctions {\n  /**\n   * Maps unconstrained R^(K-1) vector x to Unit Vector S^(K-1).\n   *\n   * @param x Unconstrained vector of length K-1\n   * @param K Dimension of the embedding space (output vector size)\n   * @return Unit vector of length K\n   */\n  vector hyper_tanh_to_unit_jacobian(vector x, int K) {\n    vector[K] y;\n    real r = 1.0;\n    \n    for (i in 1:K - 2) {\n      real val = x[i];\n      y[i] = r * tanh(val);\n      real cosh_val = cosh(val);\n      r = r * inv(cosh_val);\n      real power = K - i; \n      jacobian += -power * log(cosh_val);\n    }\n\n    real last_x = x[K-1];\n    jacobian += log(2.0) - log1p(square(last_x));\n  \n    real denom = 1.0 + square(last_x);\n    \n    y[K-1] = r * (1.0 - square(last_x)) / denom;\n    y[K] = r * (2.0 * last_x) / denom;\n    \n    return y;\n  }\n}\n\ndata {\n  int<lower=2> K;\n}\n\nparameters {\n  vector[K - 1] x_raw; // Unconstrained\n}\n\ntransformed parameters {\n  vector[K] mu = hyper_tanh_to_unit_jacobian(x_raw, K);\n}\n\nmodel {\n  // uniform on the sphere\n}\n```\n\n## 6. Conclusion\n\nThe hyper-tanh peel parameterization offers a robust alternative to @muller1959's method for Bayesian modeling. It uses exactly $K-1$ parameters, avoids the singularity at the origin by mapping from the pole, and might offer some interesting priors on the pullback.",
    "supporting": [
      "a-better-unit-vector_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}