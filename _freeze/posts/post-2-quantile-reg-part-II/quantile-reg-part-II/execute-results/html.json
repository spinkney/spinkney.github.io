{
  "hash": "376a1e88cf7f7b6969a86ffc5942b9dc",
  "result": {
    "markdown": "---\ntitle: \"Quantile Regressions in Stan: Part II\"\nauthor: \"Sean Pinkney\"\ndate: last-modified\ncategories: [model, stan]\nbibliography: references.bib\ndraft: false\n---\n\n::: {.cell}\n\n:::\n\n\nQuantile regressions are relatively new in the Bayesian literature first appearing in @yu who described an asymmetric Laplace distribution to estimate the conditional quantiles.\n\n# Quantile regression with score \n\n## Are the standard errors of `beta` off in the asymmetric Laplace?\n\n## Score function\n\n\n::: {.cell output.var='score_qr.stan' hash='quantile-reg-part-II_cache/html/unnamed-chunk-2_2b0bfbb0edef88ad5bfe63ddccc2791a'}\n\n```{.stan .cell-code}\nfunctions{\n    vector q_loss(real q, vector u){\n        return (fabs(u) + (2 * q - 1) * u);\n    }\n    \n    vector score(real q, vector y, matrix x, vector beta) {\n      int N = num_elements(y);\n      int P = num_elements(beta);\n \n      return x' * q_loss(q, y - x * beta);\n    }\n    \n    real working_lpdf (vector y, vector s, matrix L) {\n      int N = num_elements(y);\n      return -inv(2 * N) * (s' * L) * (L' * s);\n    }\n    \n    matrix make_w (matrix x, real q) {\n      int N = rows(x);\n      int P = cols(x);\n      real alpha = inv(q * (1 - q));\n      matrix[P, P] out = rep_matrix(0., P, P);\n      \n      for (n in 1:N)\n        out += x[n]' * x[n];\n        \n      return alpha * inverse( out ) * N;\n    }\n}\ndata {\n    int N;                 // Number of observation\n    int P;                 // Number of predictors\n    real q;\n    vector[N] y;           // Response variable sorted\n    matrix[N, P] x;\n}\ntransformed data {\n  matrix[P, P] W = make_w(x, q);\n}\nparameters {\n   vector[P] beta;\n}\nmodel {\n  vector[P] score_vec = score(q, y, x, beta);\n\n  beta ~ normal(0, 4);\n \n  target += -score_vec' * W * score_vec * inv(2 * N);\n}\n```\n:::\n\n\n### Multiple quantiles with the score representation\n\n\n::: {.cell output.var='multiple_score_qr.stan' hash='quantile-reg-part-II_cache/html/unnamed-chunk-3_b7b761c18432ab008def74d4a74642cf'}\n\n```{.stan .cell-code}\nfunctions{\n  matrix kronecker(matrix A, matrix B) {\n    matrix[rows(A) * rows(B), cols(A) * cols(B)] C;\n    int m = rows(A);\n    int n = cols(A);\n    int p = rows(B);\n    int q = cols(B);\n    for (i in 1:m) {\n      for (j in 1:n) {\n        int row_start = (i - 1) * p + 1;\n        int row_end = (i - 1) * p + p;\n        int col_start = (j - 1) * q + 1;\n        int col_end = (j - 1) * q + q;\n        C[row_start:row_end, col_start:col_end] = A[i, j] * B;\n      }\n    }\n    return C;\n}\n  \n  vector q_loss(real q, vector u){\n      return (abs(u) + (2 * q - 1) * u);\n  }\n    \n  matrix score(vector q, vector y, matrix x, array[] vector beta) {\n    int N = num_elements(y);\n    int P = num_elements(beta[ , 1]);\n    int K = num_elements(q);\n    matrix[K, P] out;\n    \n    for (k in 1:K) {\n      out[k] = (x' * q_loss(q[k], y - x * to_vector(beta[ ,k])))';\n    }\n    \n    return out;\n  }\n\n  matrix make_w (matrix x, vector q) {\n    int N = rows(x);\n    int P = cols(x);\n    int m = num_elements(q);\n    matrix[m * P, m * P] out;\n    \n    matrix[m, m] Q;\n    matrix[P, P] G = crossprod(x) / N;\n    \n    for (i in 1:m) {\n      Q[i, i] = q[i] * (1 - q[i]);\n      for (j in 1:i - 1) {\n        Q[i, j] = min([q[i], q[j]]) - q[i] * q[j];\n        Q[j, i] = Q[i, j];\n      }\n    }\n    \n    return kronecker(inverse(G), inverse(Q));\n  }\n}\ndata {\n    int N;            // Number of observation\n    int P;            // Number of predictors\n    int K;            // Number of quantiles\n    vector[K] q;\n    vector[N] y;      // Response variable sorted\n    matrix[N, P] x;\n}\ntransformed data {\n  matrix[K * P, K * P] W = make_w(x, q);\n}\nparameters {\n  // can add ordered constraint here\n   array[P] vector[K] beta;\n}\nmodel {\n  vector[K * P] score_out = to_vector(score(q, y, x, beta));\n  \n  for (i in 1:K) \n    beta[, i] ~ normal(0, 4);\n \n  target += -score_out' * W * score_out / (2 * N); \n}\n```\n:::\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}